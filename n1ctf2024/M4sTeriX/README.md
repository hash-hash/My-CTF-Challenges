## M4sTeriX

+ Category: **Crypto**
+ Difficulty: â˜…â˜…â˜…
+ Tag: **ISD, HSSP, MT19937**

## Description

I know that the matrix master is always performing tedious and error-prone matrix operations day after day : (

## Solution

### I. Solving a variant of  Hidden Subset Sum Problem

$\vec{c}$ is generated in the form of $\vec{c} = \vec{s}\times A+\alpha\cdot \vec{e}$ .

We need to solve for $A$ given $\vec{c},\vec{e}$. The problem is similar to Hidden Subset Sum Problem.

First, let $\mathcal{L}^\bot$ 
be an orthogonal lattice  of $(\vec{c}, \vec{e})$.

Then compute a LLL-reduced basis $\mathcal{L}$ of $\mathcal{L}^\bot$ .

For every $\vec{h_j}\in\mathcal{L}$ $\Rightarrow \langle\vec{h_j},c\rangle=\sum_i s_i\cdot \langle\vec{a_i},\vec{h_j}\rangle+\alpha\cdot\langle\vec{e},\vec{h_j}\rangle=0\ mod\ q$ .

$\Rightarrow \sum_i s_i\cdot \langle \vec{a_i},\vec{\mathcal{h_j}}\rangle=0\ mod\ q$ .

The main observation is that $\vec{a_i},\vec{h_j}$ are short vectors, so $\langle\vec{a_i},\vec{h_j}\rangle$ is small.

When the value is smaller than the shortest orthogonal vector of $\vec{s}$, it implies that $\langle \vec{a_i},\vec{\mathcal{h_j}}\rangle=0\ mod\ q$ .

i.e. $\vec{a_i}$ is in the orthogonal lattice $\mathcal{L'}^\bot$ of $\vec{h_j}$. Therefore, by compute the LLL-reduced basis of $\mathcal{L'}^\bot$, we obtain some linear combination of $\vec{a_i}$.

### II. Recovering MT19937

It's important to note that even if we use BKZ or some other techniques, it's also hard to recover the order of vectors in $A$. But we can use the linear combination of $\vec{a_i}$ to obtain $\epsilon$ which generated by randrange  through solving the equations. Yeah, just an simple MT19937 problem. After this, $\sigma$ can be recovered. Then use LLL to get $A$ .

### III. Use ISD to solve SDP in $Z_{256}$

This part need solving a Decoding Problem over $Z_{256}$. SDP is meaningless over $Z_{256}$. It's weaker than that over $Z_2$ under the same parameters. Note that we can ignore the part of the error that divisible by 2 over $Z_2$. Get the location of error that not divisible by 2 in error vector through ISD. Next, subtract these position is 1 in $e,s$ then dividing everything by 2. We get another ISD part. Here, our error corresponds to the second bit of the original value. Repeating this operation eight times, we can recover all bits of e.

### Some implementation details

1. Flatter is used as a substitute for LLL to finish lattice reduction.
2. Use multiprocessing to accelerate the solving of 20 ISD instances.

### Some surprising things (or you could say, shocking).

SageMath random is also unsafe random ðŸ¤¯. This observation completely bypassed the entire problem.
